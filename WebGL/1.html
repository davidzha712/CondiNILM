<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CondiNILM / NILMFormer Architecture</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --text-main: #ffffff;
            --text-muted: #a0a0b0;
            --panel-bg: rgba(20, 20, 35, 0.85);
            --border-color: rgba(255, 255, 255, 0.1);
            
            --col-input: #4fc3f7;
            --col-embed: #26c6da;
            --col-trans: #ffa726;
            --col-film: #f48fb1;
            --col-gate: #ce93d8;
            --col-out: #66bb6a;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-main);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none; /* Let clicks pass through to canvas */
        }

        .header {
            position: absolute;
            top: 20px;
            left: 30px;
            pointer-events: auto;
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 600;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .header p {
            margin: 5px 0 0 0;
            color: var(--text-muted);
            font-size: 14px;
        }

        /* Config Panel */
        .config-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px 20px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            min-width: 200px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .config-panel h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }

        .config-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 13px;
        }
        
        .config-item .val {
            font-family: monospace;
            color: var(--col-trans);
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            display: flex;
            gap: 15px;
        }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        /* Detail Card */
        #detail-card {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            width: 320px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transform: translateY(120%);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0;
        }

        #detail-card.active {
            transform: translateY(0);
            opacity: 1;
        }

        #detail-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0;
            box-shadow: none;
        }
        #detail-close:hover {
            color: white;
            transform: none;
        }

        #detail-title {
            margin: 0 0 10px 0;
            color: var(--col-input);
        }
        
        #detail-shape {
            font-family: monospace;
            background: rgba(0,0,0,0.3);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 13px;
            margin-bottom: 10px;
            display: inline-block;
        }

        #detail-desc {
            font-size: 14px;
            line-height: 1.5;
            color: #d0d0d0;
        }

        /* Tooltip */
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            white-space: nowrap;
        }

        /* CSS2D Object Styles */
        .node-label {
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            text-align: center;
            margin-top: 30px;
        }

        .tensor-shape {
            color: #b0bec5;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.6);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            pointer-events: none;
            margin-bottom: 35px;
        }

        /* Loading */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 1000;
            pointer-events: none;
        }

        /* Responsive */
        @media (max-width: 640px) {
            .header { top: 10px; left: 15px; }
            .header h1 { font-size: 18px; }
            .header p { font-size: 12px; }
            .config-panel {
                top: auto;
                bottom: 80px;
                right: 10px;
                left: 10px;
                min-width: auto;
            }
            .controls { gap: 10px; bottom: 15px; }
            .controls button { padding: 8px 14px; font-size: 12px; }
            #detail-card { width: auto; left: 10px; right: 10px; bottom: 15px; }
        }
    </style>
    
    <!-- Import maps polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
<style>.nav-back{display:inline-flex;align-items:center;gap:6px;color:#4fc3f7;text-decoration:none;font-size:13px;font-family:-apple-system,BlinkMacSystemFont,monospace;opacity:0.7;transition:opacity .2s;white-space:nowrap}.nav-back:hover{opacity:1;color:#81d4fa}.nav-back svg{width:14px;height:14px;fill:currentColor}</style>
</head>
<body data-condinilm="true">

    <div id="loader">Initializing WebGL...</div>

    <div id="canvas-container"></div>
    <div id="tooltip"></div>

    <div id="ui-layer">
        <div class="header">
            <a class="nav-back" href="/">&larr; Home</a>
            <h1>CondiNILM</h1>
            <p>NILMFormer Architecture Visualization</p>
        </div>

        <div class="config-panel">
            <h3>Configuration</h3>
            <div class="config-item"><span>Sequence Length</span><span class="val">480</span></div>
            <div class="config-item"><span>c_in (Agg. Power)</span><span class="val">1</span></div>
            <div class="config-item"><span>c_embedding</span><span class="val">8</span></div>
            <div class="config-item"><span>d_model</span><span class="val">96</span></div>
            <div class="config-item"><span>n_head</span><span class="val">8</span></div>
            <div class="config-item"><span>n_encoder_layers</span><span class="val">3</span></div>
            <div class="config-item"><span>c_out (Devices)</span><span class="val">5</span></div>
            <div class="config-item"><span>mask_diagonal</span><span class="val">True</span></div>
            <div class="config-item"><span>use_film</span><span class="val">True</span></div>
        </div>

        <div class="controls">
            <button id="btn-play">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M8 5v14l11-7z"/></svg>
                Auto Tour
            </button>
            <button id="btn-reset">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                Reset View
            </button>
        </div>

        <div id="detail-card">
            <button id="detail-close">âœ–</button>
            <h2 id="detail-title">Stage Name</h2>
            <div id="detail-shape">(B, X, Y)</div>
            <div id="detail-desc">Description of this processing stage.</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- Configuration & Data ---
        const COLORS = {
            input: 0x4fc3f7,
            embed: 0x26c6da,
            trans: 0xffa726,
            film: 0xf48fb1,
            gate: 0xce93d8,
            out: 0x66bb6a
        };

        const NODE_DATA = [
            // Main Path
            { id: 'in', name: 'Input', shape: '(B, 7, 480)', type: 'input', desc: 'Aggregate power reading + 6 temporal features (hour, day, etc.) spanning 8 hours at 1-min resolution.', x: -20, y: 0, z: 0 },
            { id: 'norm', name: 'Instance Norm', shape: '(B, 7, 480)', type: 'embed', desc: 'Per-sample normalization to handle different baseline power levels.', x: -16, y: 0, z: 0 },
            { id: 'conv', name: 'Dilated Conv', shape: '(B, 8, 480)', type: 'embed', desc: '4 layers of 1D convolutions with increasing dilations [1,2,4,8] to extract local temporal patterns.', x: -12, y: 0, z: 0 },
            { id: 'pos', name: 'Positional Enc.', shape: '(B, 8, 480)', type: 'embed', desc: 'Learnable positional embeddings added to retain sequence order information.', x: -8, y: 0, z: 0 },
            { id: 'proj', name: 'Input Proj', shape: '(B, 96, 480)', type: 'trans', desc: 'Linear projection scaling features up to d_model (96) for the Transformer.', x: -4, y: 0, z: 0 },
            
            // Transformer Stack
            { id: 'enc0', name: 'Encoder Layer 0', shape: '(B, 480, 96)', type: 'trans', desc: 'Self-attention with Diagonal Masking + FFN + FiLM Modulation.', x: 0, y: 0, z: 0, isStack: true },
            { id: 'enc1', name: 'Encoder Layer 1', shape: '(B, 480, 96)', type: 'trans', desc: 'Self-attention with Diagonal Masking + FFN + FiLM Modulation.', x: 3, y: 0, z: 0, isStack: true },
            { id: 'enc2', name: 'Encoder Layer 2', shape: '(B, 480, 96)', type: 'trans', desc: 'Self-attention with Diagonal Masking + FFN + FiLM Modulation.', x: 6, y: 0, z: 0, isStack: true },
            
            // FiLM Side Path
            { id: 'film_ext', name: 'Condition Extractor', shape: 'Features', type: 'film', desc: 'Extracts global statistical features (FFT, electrical stats) to generate device-specific affine transformations (gamma, beta).', x: 3, y: -6, z: 4 },

            // Device Fan-out (Output Heads)
            { id: 'dev0', name: 'Kettle Head', shape: '(B, 1, 480)', type: 'out', desc: 'SparseDeviceCNN bypass. High power, short duration.', x: 12, y: 8, z: 0 },
            { id: 'dev1', name: 'Microwave Head', shape: '(B, 1, 480)', type: 'out', desc: 'SparseDeviceCNN bypass. High power, short duration.', x: 12, y: 4, z: 0 },
            { id: 'dev2', name: 'Fridge Head', shape: '(B, 1, 480)', type: 'out', desc: 'SimpleDeviceHead. Cycling low power.', x: 12, y: 0, z: 0 },
            { id: 'dev3', name: 'Dishwasher Head', shape: '(B, 1, 480)', type: 'out', desc: 'SimpleDeviceHead. Long cycle, medium power.', x: 12, y: -4, z: 0 },
            { id: 'dev4', name: 'Washer Head', shape: '(B, 1, 480)', type: 'out', desc: 'SimpleDeviceHead. Long cycle, variable power.', x: 12, y: -8, z: 0 },

            // Final Concat
            { id: 'concat', name: 'Concatenate Output', shape: '(B, 5, 480)', type: 'gate', desc: 'Combines the 5 individual device predictions into the final output tensor. Dual Gate system applies thresholds.', x: 18, y: 0, z: 0 }
        ];

        const CONNECTIONS = [
            // Main Line
            ['in', 'norm'], ['norm', 'conv'], ['conv', 'pos'], ['pos', 'proj'], ['proj', 'enc0'], 
            ['enc0', 'enc1'], ['enc1', 'enc2'],
            // Fan out
            ['enc2', 'dev0'], ['enc2', 'dev1'], ['enc2', 'dev2'], ['enc2', 'dev3'], ['enc2', 'dev4'],
            // Concat
            ['dev0', 'concat'], ['dev1', 'concat'], ['dev2', 'concat'], ['dev3', 'concat'], ['dev4', 'concat'],
            // FiLM Routing
            ['film_ext', 'enc0', true], ['film_ext', 'enc1', true], ['film_ext', 'enc2', true],
            ['film_ext', 'dev0', true], ['film_ext', 'dev1', true], ['film_ext', 'dev2', true], ['film_ext', 'dev3', true], ['film_ext', 'dev4', true]
        ];

        // --- State ---
        let scene, camera, renderer, css2dRenderer, controls;
        let nodesMap = new Map();
        let paths = [];
        let particlesMesh;
        let particlesData = [];
        const PARTICLES_PER_PATH = 12;
        
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let hoveredNode = null;
        let isAutoTour = false;
        let tourIndex = 0;
        let tourTimer = 0;
        const TOUR_NODES = ['in', 'conv', 'proj', 'enc1', 'film_ext', 'dev2', 'concat'];

        // --- Init ---
        function init() {
            document.getElementById('loader').style.display = 'none';

            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a1a2e, 0.015);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 30);

            // Renderers
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x1a1a2e);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            css2dRenderer = new CSS2DRenderer();
            css2dRenderer.setSize(window.innerWidth, window.innerHeight);
            css2dRenderer.domElement.style.position = 'absolute';
            css2dRenderer.domElement.style.top = '0px';
            css2dRenderer.domElement.style.pointerEvents = 'none';
            document.getElementById('canvas-container').appendChild(css2dRenderer.domElement);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 60;
            controls.target.set(0, 0, 0);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            const spotLight = new THREE.SpotLight(0xffffff, 0.5);
            spotLight.position.set(-20, 20, 20);
            spotLight.angle = Math.PI/4;
            scene.add(spotLight);

            buildArchitecture();
            
            // Events
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);
            
            document.getElementById('btn-play').addEventListener('click', toggleAutoTour);
            document.getElementById('btn-reset').addEventListener('click', resetView);
            document.getElementById('detail-close').addEventListener('click', () => {
                document.getElementById('detail-card').classList.remove('active');
            });

            animate();
        }

        function buildArchitecture() {
            // Create Nodes
            const baseGeom = new RoundedBoxGeometry(2.5, 2.5, 1.5, 4, 0.2);
            const stackGeom = new RoundedBoxGeometry(2.2, 3.5, 2.2, 4, 0.2);
            
            NODE_DATA.forEach(data => {
                const geom = data.isStack ? stackGeom : baseGeom;
                const color = COLORS[data.type];
                
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: 0.2,
                    roughness: 0.2,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.9
                });

                const mesh = new THREE.Mesh(geom, material);
                mesh.position.set(data.x, data.y, data.z);
                mesh.userData = data; // Store data for interactions
                
                // Outline/Glow core
                const edgesGeom = new THREE.EdgesGeometry(geom);
                const edgesMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
                const edges = new THREE.LineSegments(edgesGeom, edgesMat);
                mesh.add(edges);

                // CSS2D Labels
                const labelDiv = document.createElement('div');
                labelDiv.className = 'node-label';
                labelDiv.textContent = data.name;
                const labelObj = new CSS2DObject(labelDiv);
                mesh.add(labelObj);

                const shapeDiv = document.createElement('div');
                shapeDiv.className = 'tensor-shape';
                shapeDiv.textContent = data.shape;
                const shapeObj = new CSS2DObject(shapeDiv);
                mesh.add(shapeObj);

                scene.add(mesh);
                nodesMap.set(data.id, mesh);
            });

            // Create Connections & Particle Paths
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
            const dashedLineMat = new THREE.LineDashedMaterial({ color: COLORS.film, dashSize: 0.5, gapSize: 0.2, transparent: true, opacity: 0.4 });

            CONNECTIONS.forEach(conn => {
                const startNode = nodesMap.get(conn[0]);
                const endNode = nodesMap.get(conn[1]);
                const isFilm = conn[2];

                if (!startNode || !endNode) return;

                const startPos = startNode.position.clone();
                const endPos = endNode.position.clone();
                
                // Adjust start/end slightly to not be inside the box
                if(startPos.x < endPos.x) {
                    startPos.x += 1.25; endPos.x -= 1.25;
                }
                
                // Create curve
                let points = [];
                points.push(startPos);
                
                // Add midpoint for nice curves if Y differs significantly
                if (Math.abs(startPos.y - endPos.y) > 1 || Math.abs(startPos.z - endPos.z) > 1) {
                    const midPos = new THREE.Vector3(
                        (startPos.x + endPos.x) / 2,
                        (startPos.y + endPos.y) / 2,
                        (startPos.z + endPos.z) / 2
                    );
                    
                    // Curve it outwards slightly
                    if(isFilm) {
                        midPos.z += 2;
                    } else {
                        midPos.x += Math.sign(endPos.x - startPos.x) * 2;
                    }
                    points.push(midPos);
                }
                
                points.push(endPos);
                
                const curve = new THREE.CatmullRomCurve3(points);
                const curveGeom = new THREE.BufferGeometry().setFromPoints(curve.getPoints(50));
                
                const line = new THREE.Line(curveGeom, isFilm ? dashedLineMat : lineMat);
                if(isFilm) line.computeLineDistances();
                scene.add(line);

                // Save path for particles
                const pathColor = isFilm ? COLORS.film : COLORS[startNode.userData.type];
                paths.push({ curve, color: new THREE.Color(pathColor) });
            });

            // Setup Particles (InstancedMesh)
            const totalParticles = paths.length * PARTICLES_PER_PATH;
            const particleGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const particleMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            particlesMesh = new THREE.InstancedMesh(particleGeom, particleMat, totalParticles);
            
            let instanceIdx = 0;
            paths.forEach((path) => {
                for (let i = 0; i < PARTICLES_PER_PATH; i++) {
                    particlesData.push({
                        pathIndex: paths.indexOf(path),
                        progress: i / PARTICLES_PER_PATH,
                        speed: 0.002 + Math.random() * 0.001
                    });
                    particlesMesh.setColorAt(instanceIdx, path.color);
                    instanceIdx++;
                }
            });
            
            particlesMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(particlesMesh);
        }

        // --- Interaction Logic ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            css2dRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Tooltip positioning
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = event.clientX + 'px';
            tooltip.style.top = event.clientY + 'px';
        }

        function onClick() {
            if (hoveredNode) {
                showDetailCard(hoveredNode.userData);
                
                // Fly camera
                const targetPos = hoveredNode.position.clone();
                targetPos.z += 15;
                targetPos.y += 2;
                
                flyCameraTo(targetPos, hoveredNode.position);
                
                isAutoTour = false;
                updatePlayButtonUI();
            }
        }

        function showDetailCard(data) {
            const card = document.getElementById('detail-card');
            document.getElementById('detail-title').textContent = data.name;
            document.getElementById('detail-title').style.color = '#' + COLORS[data.type].toString(16).padStart(6, '0');
            document.getElementById('detail-shape').textContent = data.shape;
            document.getElementById('detail-desc').textContent = data.desc;
            card.classList.add('active');
        }

        let cameraFlyTarget = null;
        let controlsTargetFly = null;

        function flyCameraTo(camPos, lookAtPos) {
            cameraFlyTarget = camPos;
            controlsTargetFly = lookAtPos;
        }

        function resetView() {
            isAutoTour = false;
            updatePlayButtonUI();
            flyCameraTo(new THREE.Vector3(0, 5, 30), new THREE.Vector3(0, 0, 0));
            document.getElementById('detail-card').classList.remove('active');
        }

        function toggleAutoTour() {
            isAutoTour = !isAutoTour;
            updatePlayButtonUI();
            if(isAutoTour) {
                tourIndex = 0;
                tourTimer = 0;
                moveToNextTourNode();
            }
        }

        function updatePlayButtonUI() {
            const btn = document.getElementById('btn-play');
            if(isAutoTour) {
                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M6 4h4v16H6zm8 0h4v16h-4z"/></svg> Stop Tour`;
                btn.style.background = 'rgba(255, 167, 38, 0.4)';
            } else {
                btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="white"><path d="M8 5v14l11-7z"/></svg> Auto Tour`;
                btn.style.background = '';
            }
        }

        function moveToNextTourNode() {
            if(!isAutoTour) return;
            const nodeId = TOUR_NODES[tourIndex];
            const node = nodesMap.get(nodeId);
            
            showDetailCard(node.userData);
            
            const camPos = node.position.clone();
            camPos.z += 12;
            camPos.x -= 2; // Offset slightly for better view
            
            flyCameraTo(camPos, node.position);
            
            tourIndex = (tourIndex + 1) % TOUR_NODES.length;
        }

        // --- Animation Loop ---
        const dummy = new THREE.Object3D();

        function animate() {
            requestAnimationFrame(animate);

            // 1. Raycasting for hover
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(Array.from(nodesMap.values()));
            
            const tooltip = document.getElementById('tooltip');

            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (hoveredNode !== object) {
                    // Reset previous
                    if (hoveredNode) hoveredNode.material.emissiveIntensity = 0.2;
                    // Set new
                    hoveredNode = object;
                    hoveredNode.material.emissiveIntensity = 0.6;
                    document.body.style.cursor = 'pointer';
                    
                    // Show tooltip
                    tooltip.innerHTML = `<strong>${object.userData.name}</strong><br>${object.userData.shape}`;
                    tooltip.style.opacity = 1;
                }
            } else {
                if (hoveredNode) {
                    hoveredNode.material.emissiveIntensity = 0.2;
                    hoveredNode = null;
                    document.body.style.cursor = 'default';
                    tooltip.style.opacity = 0;
                }
            }

            // 2. Animate Particles
            if(particlesMesh) {
                for (let i = 0; i < particlesData.length; i++) {
                    const pData = particlesData[i];
                    pData.progress += pData.speed;
                    if (pData.progress >= 1) pData.progress = 0;
                    
                    const path = paths[pData.pathIndex];
                    path.curve.getPoint(pData.progress, dummy.position);
                    dummy.updateMatrix();
                    particlesMesh.setMatrixAt(i, dummy.matrix);
                }
                particlesMesh.instanceMatrix.needsUpdate = true;
            }

            // 3. Float animation for nodes
            const time = Date.now() * 0.001;
            nodesMap.forEach((mesh) => {
                // Subtle hovering effect
                const baseZ = mesh.userData.z || 0;
                mesh.position.z = baseZ + Math.sin(time * 2 + mesh.position.x) * 0.2;
            });

            // 4. Camera flying interpolation
            if (cameraFlyTarget) {
                camera.position.lerp(cameraFlyTarget, 0.05);
                controls.target.lerp(controlsTargetFly, 0.05);
                
                // Stop interpolating if close enough
                if (camera.position.distanceTo(cameraFlyTarget) < 0.1) {
                    cameraFlyTarget = null;
                }
            }

            // 5. Auto Tour Logic
            if(isAutoTour) {
                tourTimer++;
                if(tourTimer > 300) { // ~5 seconds per node at 60fps
                    tourTimer = 0;
                    moveToNextTourNode();
                }
            }

            controls.update();
            renderer.render(scene, camera);
            css2dRenderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>